/*
Blackman AI API

A transparent AI API proxy that optimizes token usage to reduce costs.  ## Authentication  Blackman AI supports two authentication methods:  ### 1. API Key (Recommended for integrations)  Use the API key created from your dashboard:  ```bash curl -X POST https://ap.useblackman.ai/v1/completions \\   -H \"Authorization: Bearer sk_your_api_key_here\" \\   -H \"Content-Type: application/json\" \\   -d '{\"provider\": \"OpenAI\", \"model\": \"gpt-4\", \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}]}' ```  ### 2. JWT Token (For web UI)  Obtain a JWT token by logging in:  ```bash curl -X POST https://ap.useblackman.ai/v1/auth/login \\   -H \"Content-Type: application/json\" \\   -d '{\"email\": \"user@example.com\", \"password\": \"yourpassword\"}' ```  Then use the token:  ```bash curl -X POST https://ap.useblackman.ai/v1/completions \\   -H \"Authorization: Bearer your_jwt_token\" \\   -H \"Content-Type: application/json\" \\   -d '{...}' ```  ### Provider API Keys (Optional)  You can optionally provide your own LLM provider API key via the `X-Provider-Api-Key` header, or store it in your account settings.  ## Client SDKs  Auto-generated SDKs are available for 10 languages:  - **TypeScript**: [View Docs](/v1/sdks/typescript) - **Python**: [View Docs](/v1/sdks/python) - **Go**: [View Docs](/v1/sdks/go) - **Java**: [View Docs](/v1/sdks/java) - **Ruby**: [View Docs](/v1/sdks/ruby) - **PHP**: [View Docs](/v1/sdks/php) - **C#**: [View Docs](/v1/sdks/csharp) - **Rust**: [View Docs](/v1/sdks/rust) - **Swift**: [View Docs](/v1/sdks/swift) - **Kotlin**: [View Docs](/v1/sdks/kotlin)  All SDKs are generated from this OpenAPI spec using [openapi-generator](https://openapi-generator.tech).  ## Quick Start  ```python # Python example with API key import blackman_client from blackman_client import CompletionRequest  configuration = blackman_client.Configuration(     host=\"http://localhost:8080\",     access_token=\"sk_your_api_key_here\"  # Your Blackman API key )  with blackman_client.ApiClient(configuration) as api_client:     api = blackman_client.CompletionsApi(api_client)     response = api.completions(         CompletionRequest(             provider=\"OpenAI\",             model=\"gpt-4o\",             messages=[{\"role\": \"user\", \"content\": \"Hello!\"}]         )     ) ```

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package blackman

import (
	"encoding/json"
)

// checks if the CompletionOptions type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &CompletionOptions{}

// CompletionOptions struct for CompletionOptions
type CompletionOptions struct {
	MaxTokens NullableInt32 `json:"max_tokens,omitempty"`
	Stop []string `json:"stop,omitempty"`
	Stream NullableBool `json:"stream,omitempty"`
	Temperature NullableFloat32 `json:"temperature,omitempty"`
	TopP NullableFloat32 `json:"top_p,omitempty"`
}

// NewCompletionOptions instantiates a new CompletionOptions object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewCompletionOptions() *CompletionOptions {
	this := CompletionOptions{}
	return &this
}

// NewCompletionOptionsWithDefaults instantiates a new CompletionOptions object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewCompletionOptionsWithDefaults() *CompletionOptions {
	this := CompletionOptions{}
	return &this
}

// GetMaxTokens returns the MaxTokens field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CompletionOptions) GetMaxTokens() int32 {
	if o == nil || IsNil(o.MaxTokens.Get()) {
		var ret int32
		return ret
	}
	return *o.MaxTokens.Get()
}

// GetMaxTokensOk returns a tuple with the MaxTokens field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CompletionOptions) GetMaxTokensOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return o.MaxTokens.Get(), o.MaxTokens.IsSet()
}

// HasMaxTokens returns a boolean if a field has been set.
func (o *CompletionOptions) HasMaxTokens() bool {
	if o != nil && o.MaxTokens.IsSet() {
		return true
	}

	return false
}

// SetMaxTokens gets a reference to the given NullableInt32 and assigns it to the MaxTokens field.
func (o *CompletionOptions) SetMaxTokens(v int32) {
	o.MaxTokens.Set(&v)
}
// SetMaxTokensNil sets the value for MaxTokens to be an explicit nil
func (o *CompletionOptions) SetMaxTokensNil() {
	o.MaxTokens.Set(nil)
}

// UnsetMaxTokens ensures that no value is present for MaxTokens, not even an explicit nil
func (o *CompletionOptions) UnsetMaxTokens() {
	o.MaxTokens.Unset()
}

// GetStop returns the Stop field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CompletionOptions) GetStop() []string {
	if o == nil {
		var ret []string
		return ret
	}
	return o.Stop
}

// GetStopOk returns a tuple with the Stop field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CompletionOptions) GetStopOk() ([]string, bool) {
	if o == nil || IsNil(o.Stop) {
		return nil, false
	}
	return o.Stop, true
}

// HasStop returns a boolean if a field has been set.
func (o *CompletionOptions) HasStop() bool {
	if o != nil && !IsNil(o.Stop) {
		return true
	}

	return false
}

// SetStop gets a reference to the given []string and assigns it to the Stop field.
func (o *CompletionOptions) SetStop(v []string) {
	o.Stop = v
}

// GetStream returns the Stream field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CompletionOptions) GetStream() bool {
	if o == nil || IsNil(o.Stream.Get()) {
		var ret bool
		return ret
	}
	return *o.Stream.Get()
}

// GetStreamOk returns a tuple with the Stream field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CompletionOptions) GetStreamOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return o.Stream.Get(), o.Stream.IsSet()
}

// HasStream returns a boolean if a field has been set.
func (o *CompletionOptions) HasStream() bool {
	if o != nil && o.Stream.IsSet() {
		return true
	}

	return false
}

// SetStream gets a reference to the given NullableBool and assigns it to the Stream field.
func (o *CompletionOptions) SetStream(v bool) {
	o.Stream.Set(&v)
}
// SetStreamNil sets the value for Stream to be an explicit nil
func (o *CompletionOptions) SetStreamNil() {
	o.Stream.Set(nil)
}

// UnsetStream ensures that no value is present for Stream, not even an explicit nil
func (o *CompletionOptions) UnsetStream() {
	o.Stream.Unset()
}

// GetTemperature returns the Temperature field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CompletionOptions) GetTemperature() float32 {
	if o == nil || IsNil(o.Temperature.Get()) {
		var ret float32
		return ret
	}
	return *o.Temperature.Get()
}

// GetTemperatureOk returns a tuple with the Temperature field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CompletionOptions) GetTemperatureOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return o.Temperature.Get(), o.Temperature.IsSet()
}

// HasTemperature returns a boolean if a field has been set.
func (o *CompletionOptions) HasTemperature() bool {
	if o != nil && o.Temperature.IsSet() {
		return true
	}

	return false
}

// SetTemperature gets a reference to the given NullableFloat32 and assigns it to the Temperature field.
func (o *CompletionOptions) SetTemperature(v float32) {
	o.Temperature.Set(&v)
}
// SetTemperatureNil sets the value for Temperature to be an explicit nil
func (o *CompletionOptions) SetTemperatureNil() {
	o.Temperature.Set(nil)
}

// UnsetTemperature ensures that no value is present for Temperature, not even an explicit nil
func (o *CompletionOptions) UnsetTemperature() {
	o.Temperature.Unset()
}

// GetTopP returns the TopP field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CompletionOptions) GetTopP() float32 {
	if o == nil || IsNil(o.TopP.Get()) {
		var ret float32
		return ret
	}
	return *o.TopP.Get()
}

// GetTopPOk returns a tuple with the TopP field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CompletionOptions) GetTopPOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return o.TopP.Get(), o.TopP.IsSet()
}

// HasTopP returns a boolean if a field has been set.
func (o *CompletionOptions) HasTopP() bool {
	if o != nil && o.TopP.IsSet() {
		return true
	}

	return false
}

// SetTopP gets a reference to the given NullableFloat32 and assigns it to the TopP field.
func (o *CompletionOptions) SetTopP(v float32) {
	o.TopP.Set(&v)
}
// SetTopPNil sets the value for TopP to be an explicit nil
func (o *CompletionOptions) SetTopPNil() {
	o.TopP.Set(nil)
}

// UnsetTopP ensures that no value is present for TopP, not even an explicit nil
func (o *CompletionOptions) UnsetTopP() {
	o.TopP.Unset()
}

func (o CompletionOptions) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o CompletionOptions) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if o.MaxTokens.IsSet() {
		toSerialize["max_tokens"] = o.MaxTokens.Get()
	}
	if o.Stop != nil {
		toSerialize["stop"] = o.Stop
	}
	if o.Stream.IsSet() {
		toSerialize["stream"] = o.Stream.Get()
	}
	if o.Temperature.IsSet() {
		toSerialize["temperature"] = o.Temperature.Get()
	}
	if o.TopP.IsSet() {
		toSerialize["top_p"] = o.TopP.Get()
	}
	return toSerialize, nil
}

type NullableCompletionOptions struct {
	value *CompletionOptions
	isSet bool
}

func (v NullableCompletionOptions) Get() *CompletionOptions {
	return v.value
}

func (v *NullableCompletionOptions) Set(val *CompletionOptions) {
	v.value = val
	v.isSet = true
}

func (v NullableCompletionOptions) IsSet() bool {
	return v.isSet
}

func (v *NullableCompletionOptions) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCompletionOptions(val *CompletionOptions) *NullableCompletionOptions {
	return &NullableCompletionOptions{value: val, isSet: true}
}

func (v NullableCompletionOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCompletionOptions) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


